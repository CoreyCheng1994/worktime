# AI 协作单链路实践：从系统认知到可并行交付

> 结论：在复杂项目中，我采用的不是多套并行框架，而是一条可重复执行的工程链路。

## 摘要
我在实践中将 AI 协作流程收敛为单链路：

`系统认知 -> 方案计划 -> 质量闸门 -> MVP交付 -> MCP调试回归 -> 扩展沉淀`

该方法的目标不是提升“代码生成量”，而是提升交付确定性：每一步都有明确输入、输出和放行条件，并且支持并行推进。

---

## 一、问题定义

我在接手已有系统时，最常见的风险来自流程顺序错误，而非编码速度不足：
- 在系统未理解完成前进入实现，导致改动边界失控；
- 测试与评审后置，问题集中在合并前暴露；
- 复用判断缺失，重复开发持续累积；
- 故障定位缺少证据链，修复依赖个人经验。

因此，我将流程重构为单链路，先保证方向正确，再放大执行效率。

---

## 二、单链路模型

## 1）系统认知
我先输入业务目标、代码范围和风险关注点，要求 AI 产出：
- 主链路（入口、状态、落点）；
- 风险清单（高耦合、不可逆、历史坑位）；
- 可复用能力清单。

这一阶段仅产出决策信息，不进入实现。

## 2）方案计划
基于认知结果，我要求 AI 对“复用/扩展/新写”给出三案对比，并明确：
- 推荐方案；
- 不选其他方案的理由；
- 变更边界与回滚策略。

该阶段产出的是可评审方案，而不是代码草稿。

## 3）接口契约并行（OpenAPI）
在进入实现前，我会先冻结 OpenAPI 契约，作为前后端并行的唯一接口依据。

前端和后端都围绕同一份契约推进：
- 前端按 schema 与 response 结构开发和联调；
- 后端按契约完成实现与校验；
- 任何接口变更必须先改契约，再改代码。

这一步的作用是把“联调博弈”转成“契约协作”，减少并行开发中的反复对齐成本。

## 4）质量闸门
进入实现前，我要求先完成：
- 主流程、边界、失败流测试清单；
- 评审结论（通过/不通过 + 阻断项）。

阻断项未清零，不进入开发。

## 5）MVP交付
我将本轮范围限定为最小闭环，明确“只做项”与“不做项”，并以必要测试作为放行标准。

MVP 通过后，才进入下一轮扩展规划。

## 6）MCP调试回归
当出现失败信号时，我按证据链执行：
1. 复现问题；
2. 抓取证据（console、network、关键节点）；
3. 根因定位；
4. 最小修复；
5. 回归验证。

涉及迁移、安全、不可逆操作时，我保持人工确认。

## 7）扩展沉淀
MVP 稳定后，我再扩展功能，并同步沉淀：
- 结构复用规则（Code Style Skills）；
- 质量门禁规则（Code Rule Skills）。

目标是把一次成功交付转化为长期可复用能力。

---

## 三、技术选型原则：新项目优先 Node.js 同构

在新项目选型上，我倾向于前后端统一使用 Node.js。

原因不是“技术潮流”，而是协作效率：
- 对 agent 来说，语法体系、工程约束和工具链是一套，心智成本更低；
- 我可以在同一上下文中同时推进前后端，不需要频繁切换语言思维；
- 代码审查和规则治理也更容易统一执行。

这条策略尤其适合以 AI 协作为主的快速迭代项目。

---

## 四、三件套在链路中的职责分工

## Browser MCP（事实层）
职责：流程摸底、故障复现、证据采集、回归验证。  
作用：把“主观判断”转为“可复查证据”。

## Code Style Skills（结构层）
职责：扫描组件/模块复用机会，判断是否抽取、是否重用、边界是否合理。  
作用：降低重复实现，避免过度抽象。

## Code Rule Skills（治理层）
职责：执行合并前门禁。  
作用：将质量要求从经验判断转为规则检查。

核心规则包括：
- 禁止动态类型逃逸（如 `any`、`@ts-ignore`）；
- 禁止超长函数与复杂度超阈值代码；
- 命名规范一致性；
- 关键逻辑注释覆盖；
- 关键路径日志覆盖。

---

## 五、效率机制：`git worktree` + 分环境自动化测试 + agent 多线程

这条链路并未降低效率，相反它支持并行化执行。

## 1）`git worktree`：任务隔离并行
我将不同需求拆分到独立 worktree，每个 worktree 聚焦各自需求，不互相干扰。

## 2）分环境自动化测试：验证并行
这里的“分环境”不是泛指测试分层，而是每个 worktree 都有自己的单元测试环境。  
实现、验证、修复可以在各自环境独立推进，避免串行等待和环境污染。

## 3）agent 多线程：执行并行
我让 agent 分线程处理实现、规则扫描、测试回归、调试定位。  
在多数轮次中，我的主要工作收敛为 `review` 与 `merge`。

## 4）中断可见性：skills + macOS 系统弹窗
并行线程带来效率的同时，也会引入一个现实问题：某个 thread 遇到异常后会中断，而我在高频协作中很难持续记住所有任务状态。  
如果中断发生在关键分支，延迟发现会直接拖慢整体交付。

为了解决这个问题，我加了一条 skills 机制：只要 agent 停止或中断，就发送一条 macOS 系统级弹窗。  
我会基于这条提醒做快速分流：
- 关键分支：立即介入；
- 非关键分支：记录后稍后介入。

这条机制很小，但在并行开发里价值很高。它把“事后发现任务中止”变成“中止即感知”，显著降低了关键任务被遗漏的概率。

以上四项组合后，效率提升是倍级的：执行并行化，状态可见化，人工时间集中在关键决策。

---

## 六、UI 收口策略：规则先行 + 美学模型二次修复

UI 我采用“先约束、后优化”的两步策略。

第一步是规则约束：
- 使用 `ui_style.md` 作为全局 UI 风格规范；
- 所有页面遵循统一的颜色、圆角、间距、组件表现和交互风格。

第二步是样式层优化：
- 功能完成后，我会让 UI 表现更强的模型（例如 Kimi 2.5 或 Gemini 3）做一轮 UI 检查与修复；
- 这轮修复只允许修改样式，不允许改动功能逻辑。

这样可以在不引入功能风险的前提下，持续提升 UI 审美与一致性。

---

## 七、放行口径（建议）

- 动态类型违规数：`= 0`
- 超长函数违规数：`= 0`
- 命名规范违规数：`= 0`
- 关键模块注释覆盖率：`>= 90%`
- 关键路径日志覆盖率：`>= 95%`
- MVP 必要测试通过率：`= 100%`

这些指标用于放行门禁，而非展示型 KPI。

---

## 八、迭代中的关键动作：修问题，更修流程

在实际迭代中，我遇到问题时不只做“点修复”，还会和 AI 一起做一次原因复盘。  
我关注的不是“这次怎么修好”，而是“下次如何少发生”。

每次复盘我都会追问四个问题：
- 这次问题是否来自规则文件约束不足？
- 是否需要补充新的规则，而不是继续口头约定？
- 是否是单元测试覆盖不足，导致问题未被提前拦截？
- 是否是 review 重点偏差，或前期问题描述不准确导致方向偏移？

如果答案是“流程问题”，我会直接更新流程本身：
- 调整规则文件；
- 增加或重写测试；
- 变更 review 清单；
- 重写需求输入模板。
这也是我持续使用这条单链路的真实感受：  
它不存在一个“绝对最优版本”，而是一个持续调整、持续取舍的过程。  
真正稳定的不是某个静态方案，而是“发现问题 -> 复盘原因 -> 更新流程”这套闭环能力。

---

## 结语

我将 AI 协作收敛为单链路之后，交付模式从“高波动快产出”转为“可控且可并行”。

对当前项目而言，最有效的实践不是引入更多框架，而是持续强化这条链路：

`认知 -> 计划 -> 闸门 -> MVP -> 调试回归 -> 扩展沉淀`

链路稳定后，效率和质量会同时改善。
